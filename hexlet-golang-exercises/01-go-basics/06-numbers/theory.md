Основы Go

# Числа и операции с ними

Числовые типы данных в Go: `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `int`, `int8`, `int16`, `int32`, `int64`, `float32`, `float64`, `complex64`, `complex128`. Зачем столько типов для чисел? Одна из главных особенностей Go — это кроссплатформенность. Пишется один код, который компилируется и запускается на любой архитектуре процессора. В своем коде предпочтительнее использовать `int` и `uint`, так как они являются архитектурно-независимыми: в момент компиляции принимают значение 32 или 64 битов под процессор.

Не нужно запоминать все эти типы. В ежедневной работе вы будете сталкиваться с:

- `int` — основной кросплатформенный тип целых чисел, может быть отрицательным
- `int64` нужен для больших чисел из внешних систем. Например, `ID` в СУБД имеет тип `bigint`. Чтобы правильно распарсить такой `ID`, используется `int64`
- `float64` — число с плавающей точкой. Чаще всего используются для математических операций. Например, функция `math.Max()`, определяющая наибольшее число, принимает аргументы в виде `float64`.

В Go имеется стандартный набор арифметических операций:

```go
x := 10
y := 5

// сложение
x + y // 15

// вычитание
x - y // 5

// деление
x / y // 2

// умножение
x * y // 50
```

Любые операции осуществляются только над числами одинакового типа:

```go
x := 5.05
y := 10

x + y  // invalid operation: x + y (mismatched types float64 and int)
```

Чтобы осуществить сложение из прошлого примера, нам нужно конвертировать значения к одному типу

```go
x := 5.05
y := 10

x + float64(y)  // 15.05
```

Числовые типы конвертируются без проблем между собой, однако есть нюансы, о которых стоит помнить:

```go
// нельзя конвертировать float64 к целому числу, если после точки не только нули
x := int64(5.05) // ошибка компиляции: constant 5.05 truncated to integer

x := int64(5.00) // OK

// uint не может быть отрицательным
x := uint(-5) // constant -5 overflows uint
```

Приведенные выше примеры вызовут ошибки компиляции, поэтому вам не удастся «выстрелить себе в ногу». Однако существуют способы обмануть компилятор, и тогда вы получите неявное поведение в коде:

```go
a, _ := strconv.Atoi("-42")

// ошибки компиляции нет, но число было преобразовано в положительное путем прибавления MAX_UINT+1. MAX_UINT = 18446744073709551615
x := uint(a) // 18446744073709551574

a, _ := strconv.Atoi("5.05")

// ошибки компиляции нет, но значение всегда будет равно 0
x := int(a) // 0
```
